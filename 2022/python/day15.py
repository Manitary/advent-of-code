"""Solve Advent of Code Day 15 Year 2022."""

import re

from aocd import get_data, submit

TARGET_ROW = 2000000
BOX_MIN, BOX_MAX = 0, 4000000


def interval_merge(
    intervals: list[list[int]], new_interval: list[int]
) -> list[list[int]]:
    """Update the (sorted) list of intervals by merging a new interval."""
    if not new_interval:
        return intervals
    ans: list[list[int]] = []
    new = new_interval
    idx = len(intervals)
    for i, interval in enumerate(intervals):
        if interval[1] < new[0] - 1:
            ans.append(interval)
        elif interval[0] <= new[1] + 1:
            new[0] = min(interval[0], new[0])
            new[1] = max(interval[1], new[1])
        else:
            idx = i
            break

    ans.append(new)
    ans.extend(intervals[idx:])
    return ans


def interval_intersect(interval1: list[int], interval2: list[int]) -> list[int]:
    """Return the intersection of two given intervals."""
    l1, r1 = interval1
    l2, r2 = interval2
    if l1 > r2 or l2 > r1:
        return []
    return [max(l1, l2), min(r1, r2)]


def interval_merge_and_overlap(
    intervals: list[list[int]],
) -> tuple[list[list[int]], list[list[int]]]:
    """Return the total merge of the given intervals, and their pairwise overlaps."""
    final_intervals: list[list[int]] = []
    overlaps: list[list[int]] = []
    for i, interval in enumerate(intervals):
        final_intervals = interval_merge(
            intervals=final_intervals, new_interval=interval
        )
        for _, other in enumerate(intervals[i + 1 :]):
            overlap = interval_intersect(interval, other)
            if overlap:
                overlaps.append(overlap)
    return final_intervals, overlaps


def row_span(
    y: int,
    sensors: dict[tuple[int, int], int],
    bound: list[int] | None = None,
    merge: bool = False,
) -> list[list[int]]:
    """Return the intervals in a row that are covered by the sensors."""
    intervals: list[list[int]] = []
    for (xs, ys), r in sensors.items():
        if (dy := abs(y - ys)) <= r:
            dx = r - dy
            new_interval = [xs - dx, xs + dx]
            if bound:
                new_interval = interval_intersect(new_interval, bound)
            if merge:
                intervals = interval_merge(
                    intervals=intervals, new_interval=new_interval
                )
            else:
                intervals.append(new_interval)
    return intervals


def parse_input(data: str) -> tuple[set[tuple[int, int]], dict[tuple[int, int], int]]:
    """Return a set of beacons and a dict of sensors -> radius from the given data."""
    sensors: dict[tuple[int, int], int] = {}
    beacons: set[tuple[int, int]] = set()
    nums = list(map(int, re.findall(r"(-?\d+)", data)))
    for i in range(len(nums) // 4):
        xs, ys, xb, yb = nums[4 * i : 4 * i + 4]
        sensors[(xs, ys)] = abs(xs - xb) + abs(ys - yb)
        beacons.add((xb, yb))
    return beacons, sensors


def find_unique_hole_in_area(
    min_row: int, max_row: int, sensors: dict[tuple[int, int], int]
) -> tuple[int, int]:
    """Given the boundaries of a box, return a point not covered by the sensors.

    The search runs from min_row to max_row, it returns the first point available,
    even if multiple exist."""
    row = min_row
    old_overlaps = []
    while row <= max_row:
        # On the given row, get the intervals like in part 1, but also store their overlaps.
        ranges, new_overlaps = interval_merge_and_overlap(
            intervals=row_span(
                y=row, sensors=sensors, bound=[min_row, max_row], merge=False
            )
        )

        # If there is more than one interval, there is a one unit gap given by the missing beacon.
        if len(ranges) > 1:
            return row, ranges[0][1] + 1

        # If _all_ overlaps are of at least two points and cover the entire row,
        # the next row will also be completely covered:
        #
        # .*.*.
        # ..*..
        # .*O*. N cannot decrease by more than two each subsequent row
        # *OOO* <-- N=5
        # .*O*. <-- N=3
        # ..*..
        # .*.*.
        #
        # If two sensor disks have an overlap of N points on a given row,
        # they will keep overlapping for at least N // 2 more rows.
        #
        # The borders of two sensor disks may overlap (i.e. they are parallel and intersect):
        # in such case, they will produce a 1-point overlap (0-length interval) for some rows,
        # which prevents skipping rows if we do not account for it.
        #
        # We cannot ignore all 1-point overlaps in general, but we can ignore those that repeat
        # in consecutive rows with a left or right shift by 1 unit, as they are generated by one of:
        # * parallel borders
        # * an overlap of corners of two areas, followed by the start of two parallel borders
        # (sensors do not overlap with beacons, so their disks have a side of at least three points)
        if (
            min_overlap := min(
                (
                    y - x
                    for x, y in new_overlaps
                    if x != y  # Check all overlaps consisting of more than one point.
                    or (
                        # Check 1-point overlaps only if they may not originate
                        # from a previous 1-point overlap shifted by 1.
                        [x - 1, x - 1] not in old_overlaps
                        and [x + 1, x + 1] not in old_overlaps
                    )
                ),
                default=0,
            )
        ) > 1:
            row += min_overlap // 2 + 1
        else:
            row += 1
        old_overlaps = new_overlaps
    raise ValueError("No valid point found")


def main() -> tuple[int, int]:
    """Return the solution to part 1 and part 2."""
    data = get_data(day=15, year=2022)
    beacons, sensors = parse_input(data)
    part1_ranges = row_span(y=TARGET_ROW, sensors=sensors, merge=True)
    # Measure the lengths of the intervals, then remove any beacons lying in said intervals.
    part1 = sum(y - x + 1 for x, y in part1_ranges) - sum(
        1
        for x, y in beacons
        if y == TARGET_ROW and any(a <= x <= b for a, b in part1_ranges)
    )
    y, x = find_unique_hole_in_area(min_row=BOX_MIN, max_row=BOX_MAX, sensors=sensors)
    part2 = y + x * BOX_MAX
    return part1, part2


if __name__ == "__main__":
    ans1, ans2 = main()
    submit(ans1, part="a")
    submit(ans2, part="b")
